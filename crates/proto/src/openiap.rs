// This file is generated by tonic_build. Do not edit manually.
// (You should copy the actual generated file here. For now, this is a placeholder.)
// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListCollectionsRequest {
    #[prost(bool, tag = "1")]
    pub includehist: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCollectionsResponse {
    #[prost(string, tag = "1")]
    pub results: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropCollectionRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DropCollectionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColTimeseries {
    #[prost(string, tag = "1")]
    pub time_field: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub meta_field: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub granularity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColCollation {
    #[prost(string, tag = "1")]
    pub locale: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub case_level: bool,
    #[prost(string, tag = "3")]
    pub case_first: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub strength: i32,
    #[prost(bool, tag = "5")]
    pub numeric_ordering: bool,
    #[prost(string, tag = "6")]
    pub alternate: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub max_variable: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub backwards: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCollectionRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub collation: ::core::option::Option<ColCollation>,
    #[prost(message, optional, tag = "3")]
    pub timeseries: ::core::option::Option<ColTimeseries>,
    #[prost(int32, tag = "4")]
    pub expire_after_seconds: i32,
    #[prost(bool, tag = "5")]
    pub change_stream_pre_and_post_images: bool,
    #[prost(bool, tag = "6")]
    pub capped: bool,
    #[prost(int32, tag = "7")]
    pub max: i32,
    #[prost(int32, tag = "8")]
    pub size: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateCollectionResponse {}
/// MongoDB Query Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRequest {
    /// MongoDB Query to execute. This field is required.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    /// MongoDB Collection to query. This field is required.
    #[prost(string, tag = "2")]
    pub collectionname: ::prost::alloc::string::String,
    /// MongoDB Query projection. This field is optional.
    #[prost(string, tag = "3")]
    pub projection: ::prost::alloc::string::String,
    /// MongoDB Maximum number of documents to return. This field is optional with a default of 100.
    #[prost(int32, tag = "4")]
    pub top: i32,
    /// MongoDB Number of documents to skip, used for paging on the same query. This field is optional with a default of 0.
    #[prost(int32, tag = "5")]
    pub skip: i32,
    /// MongoDB order by. This field is optional with a default of {"_id": 1}.
    /// You can specify "timestamp" as a string or an object like {"timestamp": -1}.
    #[prost(string, tag = "6")]
    pub orderby: ::prost::alloc::string::String,
    /// Query as if you were this _id. (_id can be a user, role, or customer from the users collection)
    #[prost(string, tag = "7")]
    pub queryas: ::prost::alloc::string::String,
    /// Enabling explain will provides information on the execution of the query
    #[prost(bool, tag = "8")]
    pub explain: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResponse {
    #[prost(string, tag = "1")]
    pub results: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentVersionRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub version: i32,
    #[prost(bool, tag = "4")]
    pub decrypt: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentVersionResponse {
    #[prost(string, tag = "1")]
    pub result: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub aggregates: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub queryas: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub hint: ::prost::alloc::string::String,
    /// Enabling explain will provides information on the execution of the pipelines
    #[prost(bool, tag = "5")]
    pub explain: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateResponse {
    #[prost(string, tag = "1")]
    pub results: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub queryas: ::prost::alloc::string::String,
    /// Enabling explain will provides information on the execution of the count
    #[prost(bool, tag = "4")]
    pub explain: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CountResponse {
    #[prost(int32, tag = "1")]
    pub result: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistinctRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub field: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub queryas: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub options: ::prost::alloc::string::String,
    /// Enabling explain will provides information on the execution of the distinct
    #[prost(bool, tag = "7")]
    pub explain: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistinctResponse {
    #[prost(string, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertOneRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub item: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub w: i32,
    #[prost(bool, tag = "4")]
    pub j: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertOneResponse {
    #[prost(string, tag = "1")]
    pub result: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertManyRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub items: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub w: i32,
    #[prost(bool, tag = "4")]
    pub j: bool,
    #[prost(bool, tag = "5")]
    pub skipresults: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertManyResponse {
    #[prost(string, tag = "1")]
    pub results: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOneRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub item: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub w: i32,
    #[prost(bool, tag = "4")]
    pub j: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOneResponse {
    #[prost(string, tag = "1")]
    pub result: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub document: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub w: i32,
    #[prost(bool, tag = "5")]
    pub j: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateResult {
    #[prost(bool, tag = "1")]
    pub acknowledged: bool,
    #[prost(int32, tag = "2")]
    pub matched_count: i32,
    #[prost(int32, tag = "3")]
    pub modified_count: i32,
    #[prost(int32, tag = "4")]
    pub upserted_count: i32,
    #[prost(string, tag = "5")]
    pub upserted_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentResponse {
    #[prost(message, optional, tag = "1")]
    pub opresult: ::core::option::Option<UpdateResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertOrUpdateOneRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uniqeness: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub item: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub w: i32,
    #[prost(bool, tag = "5")]
    pub j: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertOrUpdateOneResponse {
    #[prost(string, tag = "1")]
    pub result: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertOrUpdateManyRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uniqeness: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub items: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub w: i32,
    #[prost(bool, tag = "5")]
    pub j: bool,
    #[prost(bool, tag = "6")]
    pub skipresults: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertOrUpdateManyResponse {
    #[prost(string, tag = "1")]
    pub results: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteOneRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub recursive: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteOneResponse {
    #[prost(int32, tag = "1")]
    pub affectedrows: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteManyRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub recursive: bool,
    #[prost(string, repeated, tag = "4")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteManyResponse {
    #[prost(int32, tag = "1")]
    pub affectedrows: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterQueueRequest {
    #[prost(string, tag = "1")]
    pub queuename: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterQueueResponse {
    #[prost(string, tag = "1")]
    pub queuename: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterExchangeRequest {
    #[prost(string, tag = "1")]
    pub exchangename: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub routingkey: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub addqueue: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterExchangeResponse {
    #[prost(string, tag = "1")]
    pub queuename: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueueMessageRequest {
    #[prost(string, tag = "1")]
    pub queuename: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub replyto: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub routingkey: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub exchangename: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub data: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub striptoken: bool,
    #[prost(int32, tag = "8")]
    pub expiration: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueueMessageResponse {
    #[prost(string, tag = "1")]
    pub queuename: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub replyto: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub routingkey: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub exchangename: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub data: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueueEvent {
    #[prost(string, tag = "1")]
    pub queuename: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub replyto: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub routingkey: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub exchangename: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub data: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnRegisterQueueRequest {
    #[prost(string, tag = "1")]
    pub queuename: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnRegisterQueueResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkflowInstanceRequest {
    #[prost(string, tag = "1")]
    pub targetid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflowid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub resultqueue: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub data: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub initialrun: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkflowInstanceResponse {
    #[prost(string, tag = "1")]
    pub instanceid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeOpenRpaRequest {
    /// _id from either a {"_type": "role", "rparole": true} role or {"_type": "user"} from the users colletion.
    #[prost(string, tag = "1")]
    pub robotid: ::prost::alloc::string::String,
    /// _id from a {"_type": "workflow"} from the openrpa collection. The Parameters property will show what arguments the workflow takes and returns. (in/inout/out)
    #[prost(string, tag = "2")]
    pub workflowid: ::prost::alloc::string::String,
    /// if true will not return a result until the robot has completed the run, if false will simply query the reqesut
    #[prost(bool, tag = "3")]
    pub rpc: bool,
    /// a JSON string with each of the arguments to send to the workflow ( each value must corrospond with a `in` or `inout` Parameter found on the workflow )
    #[prost(string, tag = "4")]
    pub payload: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeOpenRpaResponse {
    #[prost(string, tag = "1")]
    pub payload: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchRequest {
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub document: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnWatchRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnWatchResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ace {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub deny: bool,
    #[prost(int32, tag = "3")]
    pub rights: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Workitem {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub payload: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub priority: i32,
    #[prost(message, optional, tag = "5")]
    pub nextrun: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub lastrun: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "7")]
    pub files: ::prost::alloc::vec::Vec<WorkitemFile>,
    #[prost(string, tag = "8")]
    pub state: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub wiqid: ::prost::alloc::string::String,
    #[prost(int32, tag = "11")]
    pub retries: i32,
    #[prost(string, tag = "12")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub success_wiqid: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub failed_wiqid: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub success_wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub failed_wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub errormessage: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub errorsource: ::prost::alloc::string::String,
    #[prost(string, tag = "19")]
    pub errortype: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkitemFile {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub compressed: bool,
    #[prost(bytes = "vec", tag = "4")]
    pub file: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushWorkitemRequest {
    #[prost(string, tag = "1")]
    pub wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub wiqid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub payload: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub nextrun: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "6")]
    pub success_wiqid: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub failed_wiqid: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub success_wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub failed_wiq: ::prost::alloc::string::String,
    #[prost(int32, tag = "10")]
    pub priority: i32,
    #[prost(message, repeated, tag = "11")]
    pub files: ::prost::alloc::vec::Vec<WorkitemFile>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushWorkitemResponse {
    #[prost(message, optional, tag = "1")]
    pub workitem: ::core::option::Option<Workitem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushWorkitemsRequest {
    #[prost(string, tag = "1")]
    pub wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub wiqid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub nextrun: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub success_wiqid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub failed_wiqid: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub success_wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub failed_wiq: ::prost::alloc::string::String,
    #[prost(int32, tag = "8")]
    pub priority: i32,
    #[prost(message, repeated, tag = "9")]
    pub items: ::prost::alloc::vec::Vec<Workitem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushWorkitemsResponse {
    #[prost(message, repeated, tag = "1")]
    pub workitems: ::prost::alloc::vec::Vec<Workitem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkitemRequest {
    #[prost(message, optional, tag = "1")]
    pub workitem: ::core::option::Option<Workitem>,
    #[prost(bool, tag = "2")]
    pub ignoremaxretries: bool,
    #[prost(message, repeated, tag = "3")]
    pub files: ::prost::alloc::vec::Vec<WorkitemFile>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkitemResponse {
    #[prost(message, optional, tag = "1")]
    pub workitem: ::core::option::Option<Workitem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PopWorkitemRequest {
    #[prost(string, tag = "1")]
    pub wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub wiqid: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub includefiles: bool,
    #[prost(bool, tag = "4")]
    pub compressed: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PopWorkitemResponse {
    #[prost(message, optional, tag = "1")]
    pub workitem: ::core::option::Option<Workitem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkitemRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteWorkitemResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkItemQueue {
    #[prost(string, tag = "1")]
    pub workflowid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub robotqueue: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub amqpqueue: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub projectid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub usersrole: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub maxretries: i32,
    #[prost(int32, tag = "7")]
    pub retrydelay: i32,
    #[prost(int32, tag = "8")]
    pub initialdelay: i32,
    #[prost(string, tag = "9")]
    pub success_wiqid: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub failed_wiqid: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub success_wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub failed_wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "14")]
    pub acl: ::prost::alloc::vec::Vec<Ace>,
    #[prost(string, tag = "15")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub createdbyid: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub createdby: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "18")]
    pub created: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "19")]
    pub modifiedbyid: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub modifiedby: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "21")]
    pub modified: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "22")]
    pub version: i32,
    #[prost(string, tag = "23")]
    pub packageid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddWorkItemQueueRequest {
    #[prost(message, optional, tag = "1")]
    pub workitemqueue: ::core::option::Option<WorkItemQueue>,
    #[prost(bool, tag = "2")]
    pub skiprole: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddWorkItemQueueResponse {
    #[prost(message, optional, tag = "1")]
    pub workitemqueue: ::core::option::Option<WorkItemQueue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkItemQueueRequest {
    #[prost(message, optional, tag = "1")]
    pub workitemqueue: ::core::option::Option<WorkItemQueue>,
    #[prost(bool, tag = "2")]
    pub skiprole: bool,
    #[prost(bool, tag = "3")]
    pub purge: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkItemQueueResponse {
    #[prost(message, optional, tag = "1")]
    pub workitemqueue: ::core::option::Option<WorkItemQueue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkItemQueueRequest {
    #[prost(string, tag = "1")]
    pub wiq: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub wiqid: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub purge: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteWorkItemQueueResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeCoupon {
    #[prost(string, tag = "1")]
    pub duration: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub duration_in_months: i32,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeCustomerDiscount {
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub start: i32,
    #[prost(string, tag = "3")]
    pub customer: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub coupon: ::core::option::Option<StripeCoupon>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeCustomerAddress {
    #[prost(string, tag = "1")]
    pub line1: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub line2: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub postal_code: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub city: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub state: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub country: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeTaxVerification {
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub verified_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub verified_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeTaxId {
    #[prost(string, tag = "1")]
    pub country: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub customer: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub value: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub verification: ::core::option::Option<StripeTaxVerification>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeRecurring {
    #[prost(string, tag = "1")]
    pub interval: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub interval_count: i32,
    #[prost(int32, tag = "3")]
    pub trial_period_days: i32,
    /// string aggregate_usage = 5;
    #[prost(string, tag = "4")]
    pub usage_type: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripePrice {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub product: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub active: bool,
    #[prost(string, tag = "4")]
    pub billing_scheme: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub currency: ::prost::alloc::string::String,
    /// string lookup_key = 7;
    /// string tiers_mode = 8;
    #[prost(message, optional, tag = "6")]
    pub recurring: ::core::option::Option<StripeRecurring>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripePlan {
    #[prost(bool, tag = "1")]
    pub status: bool,
    #[prost(string, tag = "2")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub product: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub amount: i32,
    #[prost(string, tag = "5")]
    pub usage_type: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeSubscriptionItem {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub quantity: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub subscription: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub plan: ::core::option::Option<StripePlan>,
    #[prost(message, optional, tag = "5")]
    pub price: ::core::option::Option<StripePrice>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeSubscription {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub balance: i32,
    #[prost(string, tag = "3")]
    pub currency: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub subscriptions: ::prost::alloc::vec::Vec<StripeSubscription>,
    #[prost(message, repeated, tag = "5")]
    pub tax_ids: ::prost::alloc::vec::Vec<StripeTaxId>,
    #[prost(message, repeated, tag = "6")]
    pub items: ::prost::alloc::vec::Vec<StripeSubscriptionItem>,
    #[prost(string, repeated, tag = "7")]
    pub default_tax_rates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StripeCustomer {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<StripeCustomerAddress>,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub email: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub tax_ids: ::prost::alloc::vec::Vec<StripeTaxId>,
    #[prost(message, repeated, tag = "6")]
    pub subscriptions: ::prost::alloc::vec::Vec<StripeSubscription>,
    #[prost(message, optional, tag = "7")]
    pub discount: ::core::option::Option<StripeCustomerDiscount>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartAgentRequest {
    /// _id of an agent from the agents collection
    #[prost(string, tag = "1")]
    pub agentid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartAgentResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopAgentRequest {
    /// _id of an agent from the agents collection
    #[prost(string, tag = "1")]
    pub agentid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StopAgentResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentLogRequest {
    /// _id of an agent from the agents collection
    #[prost(string, tag = "1")]
    pub agentid: ::prost::alloc::string::String,
    /// Pod name, found with GetAgentPods
    #[prost(string, tag = "2")]
    pub podname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentLogResponse {
    #[prost(string, tag = "1")]
    pub result: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentPodsRequest {
    /// _id of an agent from the agents collection
    #[prost(string, tag = "1")]
    pub agentid: ::prost::alloc::string::String,
    /// get memory and cpu usage per pod, this is resource intensive and should be used sparringly
    #[prost(bool, tag = "2")]
    pub stats: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentPodsResponse {
    /// JSON array of pods
    #[prost(string, tag = "1")]
    pub results: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAgentPodRequest {
    /// _id of an agent from the agents collection
    #[prost(string, tag = "1")]
    pub agentid: ::prost::alloc::string::String,
    /// Pod name, found with GetAgentPods
    #[prost(string, tag = "2")]
    pub podname: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteAgentPodResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAgentRequest {
    /// _id of an agent from the agents collection
    #[prost(string, tag = "1")]
    pub agentid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteAgentResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Envelope {
    #[prost(string, tag = "1")]
    pub command: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub priority: i32,
    #[prost(int32, tag = "3")]
    pub seq: i32,
    #[prost(string, tag = "4")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub rid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub data: ::core::option::Option<::prost_types::Any>,
    #[prost(string, tag = "7")]
    pub jwt: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub traceid: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub spanid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PingRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PingResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Noop {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorResponse {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub code: i32,
    #[prost(string, tag = "3")]
    pub stack: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetElementRequest {
    #[prost(string, tag = "1")]
    pub xpath: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetElementResponse {
    #[prost(string, tag = "1")]
    pub xpath: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub collectionname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub mimetype: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadRequest {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mimetype: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub metadata: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub collectionname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub bytes: i32,
    #[prost(int32, tag = "4")]
    pub chunks: i32,
    #[prost(float, tag = "5")]
    pub mb: f32,
    #[prost(int32, tag = "6")]
    pub elapsed_time: i32,
    #[prost(float, tag = "7")]
    pub mbps: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginStream {
    #[prost(string, tag = "1")]
    pub checksum: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub stat: ::core::option::Option<Stat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stream {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EndStream {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Stat {
    #[prost(float, tag = "1")]
    pub birthtime_ms: f32,
    #[prost(int32, tag = "2")]
    pub blksize: i32,
    #[prost(int32, tag = "3")]
    pub blocks: i32,
    #[prost(message, optional, tag = "4")]
    pub ctime: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(float, tag = "5")]
    pub ctime_ms: f32,
    #[prost(int32, tag = "6")]
    pub dev: i32,
    #[prost(int32, tag = "7")]
    pub gid: i32,
    #[prost(int32, tag = "8")]
    pub ino: i32,
    #[prost(int32, tag = "9")]
    pub mode: i32,
    #[prost(message, optional, tag = "10")]
    pub mtime: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(float, tag = "11")]
    pub mtime_ms: f32,
    #[prost(int32, tag = "12")]
    pub nlink: i32,
    #[prost(int32, tag = "13")]
    pub rdev: i32,
    #[prost(int32, tag = "14")]
    pub size: i32,
    #[prost(int32, tag = "15")]
    pub uid: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomCommandRequest {
    #[prost(string, tag = "1")]
    pub command: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub data: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomCommandResponse {
    #[prost(string, tag = "1")]
    pub result: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigninRequest {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub jwt: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub ping: bool,
    #[prost(bool, tag = "5")]
    pub validateonly: bool,
    #[prost(string, tag = "6")]
    pub agent: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub longtoken: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigninResponse {
    #[prost(string, tag = "1")]
    pub jwt: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<User>,
    #[prost(string, tag = "3")]
    pub config: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshToken {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub jwt: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub user: ::core::option::Option<User>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Role {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub email: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub roles: ::prost::alloc::vec::Vec<Role>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Customer {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub stripeid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub userid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub country: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub vattype: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub vatnumber: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub taxrate: ::prost::alloc::string::String,
    #[prost(int32, tag = "12")]
    pub tax: i32,
    #[prost(string, tag = "13")]
    pub coupon: ::prost::alloc::string::String,
    #[prost(bool, tag = "14")]
    pub hascard: bool,
    #[prost(string, tag = "15")]
    pub memory: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub openflowuserplan: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub supportplan: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub supporthourplan: ::prost::alloc::string::String,
    #[prost(string, tag = "19")]
    pub subscriptionid: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub admins: ::prost::alloc::string::String,
    #[prost(string, tag = "21")]
    pub users: ::prost::alloc::string::String,
    #[prost(string, tag = "22")]
    pub customattr1: ::prost::alloc::string::String,
    #[prost(string, tag = "23")]
    pub customattr2: ::prost::alloc::string::String,
    #[prost(string, tag = "24")]
    pub customattr3: ::prost::alloc::string::String,
    #[prost(string, tag = "25")]
    pub customattr4: ::prost::alloc::string::String,
    #[prost(string, tag = "26")]
    pub customattr5: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "27")]
    pub domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "28")]
    pub dbusage: i32,
    #[prost(bool, tag = "29")]
    pub dblocked: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnsureCustomerRequest {
    #[prost(message, optional, tag = "1")]
    pub customer: ::core::option::Option<Customer>,
    #[prost(message, optional, tag = "2")]
    pub stripe: ::core::option::Option<StripeCustomer>,
    #[prost(string, tag = "3")]
    pub ensureas: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnsureCustomerResponse {
    #[prost(message, optional, tag = "1")]
    pub customer: ::core::option::Option<Customer>,
    #[prost(message, optional, tag = "2")]
    pub stripe: ::core::option::Option<StripeCustomer>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexRequest {
    /// Collection to create index on
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    /// JSON string with indexes to create, for instance {"age": 1, "name": "text"}
    #[prost(string, tag = "2")]
    pub index: ::prost::alloc::string::String,
    /// optional JSON string with index option, for instance { unique: true }
    #[prost(string, tag = "3")]
    pub options: ::prost::alloc::string::String,
    /// Index name. Leave blank to let mongodb auto generate it
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexResponse {
    /// Index name
    #[prost(string, tag = "1")]
    pub result: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexesRequest {
    /// Collection to create index on
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexesResponse {
    /// List of indexes for collection
    #[prost(string, tag = "1")]
    pub results: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropIndexRequest {
    /// Collection to create index on
    #[prost(string, tag = "1")]
    pub collectionname: ::prost::alloc::string::String,
    /// Index name
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DropIndexResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePackageRequest {
    /// id of package to delete,found in `agents` collection with {"_type": "package"}
    #[prost(string, tag = "1")]
    pub packageid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeletePackageResponse {}
/// Generated client implementations.
pub mod flow_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing OpenIAP Flow (OpenFlow)
    #[derive(Debug, Clone)]
    pub struct FlowServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FlowServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FlowServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FlowServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FlowServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Establishes a bidirectional streaming connection for sending and receiving Envelopes.
        /// This method is used to set up a real-time data stream for communication.
        /// Returns a bidirectional stream of Envelopes.
        pub async fn setup_stream(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::Envelope>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Envelope>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/SetupStream",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "SetupStream"));
            self.inner.streaming(req, path, codec).await
        }
        /// Signs in a user with the provided SigninRequest and returns a SigninResponse.
        /// This method authenticates a user and provides access to the OpenFlow system.
        /// Returns a SigninResponse containing authentication details.
        pub async fn signin(
            &mut self,
            request: impl tonic::IntoRequest<super::SigninRequest>,
        ) -> std::result::Result<tonic::Response<super::SigninResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/Signin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "Signin"));
            self.inner.unary(req, path, codec).await
        }
        /// Downloads a file from OpenFlow
        /// This method retrieves files from the OpenFlow system based on the specified criteria.
        /// This will initiaize a DownLoad stream, and once completed send send a DownloadResponse
        pub async fn download(
            &mut self,
            request: impl tonic::IntoRequest<super::DownloadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DownloadResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/Download",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "Download"));
            self.inner.unary(req, path, codec).await
        }
        /// Uploads data based on the provided UploadRequest and returns an UploadResponse.
        /// This method allows users to upload data to the OpenFlow system.
        /// Returns an UploadResponse confirming the successful upload.
        pub async fn upload(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadRequest>,
        ) -> std::result::Result<tonic::Response<super::UploadResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/Upload",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "Upload"));
            self.inner.unary(req, path, codec).await
        }
        /// Executes a custom command in OpenIAP Flow.
        /// This method enables the execution of custom commands within the OpenFlow system.
        /// Returns a CustomCommandResponse with the result of the command execution.
        pub async fn custom_command(
            &mut self,
            request: impl tonic::IntoRequest<super::CustomCommandRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomCommandResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/CustomCommand",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "CustomCommand"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all MongoDB collections the user has access to.
        /// This method provides a list of collections that the user can interact with in the MongoDB database.
        /// Returns a ListCollectionsResponse containing collection names.
        pub async fn list_collections(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCollectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCollectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/ListCollections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "ListCollections"));
            self.inner.unary(req, path, codec).await
        }
        /// Drops a MongoDB Collection, requires user is a member of admins role.
        /// This method allows administrators to delete a MongoDB collection.
        /// Returns a DropCollectionResponse confirming the deletion.
        pub async fn drop_collection(
            &mut self,
            request: impl tonic::IntoRequest<super::DropCollectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DropCollectionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/DropCollection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "DropCollection"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new MongoDB collection, useful if you need to create with parameters like creating a TimeSeries Collection.
        /// This method creates a new MongoDB collection with optional parameters.
        /// Returns a CreateCollectionResponse indicating the success of collection creation.
        pub async fn create_collection(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCollectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateCollectionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/CreateCollection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "CreateCollection"));
            self.inner.unary(req, path, codec).await
        }
        /// Performs a query using QueryRequest and returns a QueryResponse.
        /// This method executes a query operation in the MongoDB database.
        /// Returns a QueryResponse with query results.
        pub async fn query(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/Query",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("openiap.FlowService", "Query"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a document's version using GetDocumentVersionRequest and returns a GetDocumentVersionResponse.
        /// This method retrieves a specific version of a document.
        /// Returns a GetDocumentVersionResponse with the requested document version.
        pub async fn get_document_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDocumentVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDocumentVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/GetDocumentVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "GetDocumentVersion"));
            self.inner.unary(req, path, codec).await
        }
        /// Aggregates data based on AggregateRequest and returns an AggregateResponse.
        /// This method performs data aggregation operations on the MongoDB database.
        /// Returns an AggregateResponse with the aggregated data.
        pub async fn aggregate(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AggregateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/Aggregate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "Aggregate"));
            self.inner.unary(req, path, codec).await
        }
        /// Counts documents based on CountRequest and returns a CountResponse.
        /// This method counts documents in the MongoDB database based on specified criteria.
        /// Returns a CountResponse with the count result.
        pub async fn count(
            &mut self,
            request: impl tonic::IntoRequest<super::CountRequest>,
        ) -> std::result::Result<tonic::Response<super::CountResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/Count",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("openiap.FlowService", "Count"));
            self.inner.unary(req, path, codec).await
        }
        /// Inserts a single document using InsertOneRequest and returns an InsertOneResponse.
        /// This method inserts a single document into the MongoDB database.
        /// Returns an InsertOneResponse confirming the insertion.
        pub async fn insert_one(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertOneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InsertOneResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/InsertOne",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "InsertOne"));
            self.inner.unary(req, path, codec).await
        }
        /// Inserts multiple documents using InsertManyRequest and returns an InsertManyResponse.
        /// This method inserts multiple documents into the MongoDB database.
        /// Returns an InsertManyResponse confirming the insertions.
        pub async fn insert_many(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertManyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InsertManyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/InsertMany",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "InsertMany"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a single document using UpdateOneRequest and returns an UpdateOneResponse.
        /// This method updates a single document in the MongoDB database.
        /// Returns an UpdateOneResponse confirming the update.
        pub async fn update_one(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateOneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateOneResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/UpdateOne",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "UpdateOne"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates documents using UpdateDocumentRequest and returns an UpdateDocumentResponse.
        /// This method updates multiple documents in the MongoDB database.
        /// Returns an UpdateDocumentResponse confirming the updates.
        pub async fn update_document(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateDocumentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/UpdateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "UpdateDocument"));
            self.inner.unary(req, path, codec).await
        }
        /// Inserts or updates a single document using InsertOrUpdateOneRequest and returns an InsertOrUpdateOneResponse.
        /// This method either inserts or updates a single document in the MongoDB database.
        /// Returns an InsertOrUpdateOneResponse confirming the operation.
        pub async fn insert_or_update_one(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertOrUpdateOneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InsertOrUpdateOneResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/InsertOrUpdateOne",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "InsertOrUpdateOne"));
            self.inner.unary(req, path, codec).await
        }
        /// Inserts or updates multiple documents using InsertOrUpdateManyRequest and returns an InsertOrUpdateManyResponse.
        /// This method either inserts or updates multiple documents in the MongoDB database.
        /// Returns an InsertOrUpdateManyResponse confirming the operation.
        pub async fn insert_or_update_many(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertOrUpdateManyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InsertOrUpdateManyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/InsertOrUpdateMany",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "InsertOrUpdateMany"));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single document using DeleteOneRequest and returns a DeleteOneResponse.
        /// This method deletes a single document from the MongoDB database.
        /// Returns a DeleteOneResponse confirming the deletion.
        pub async fn delete_one(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteOneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteOneResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/DeleteOne",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "DeleteOne"));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes multiple documents using DeleteManyRequest and returns a DeleteManyResponse.
        /// This method deletes multiple documents from the MongoDB database.
        /// Returns a DeleteManyResponse confirming the deletions.
        pub async fn delete_many(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteManyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteManyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/DeleteMany",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "DeleteMany"));
            self.inner.unary(req, path, codec).await
        }
        /// Registers a queue using RegisterQueueRequest and returns a RegisterQueueResponse.
        /// This method registers and starts consuming a queue for message routing using AMQP
        /// Returns a RegisterQueueResponse confirming the registration.
        pub async fn register_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/RegisterQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "RegisterQueue"));
            self.inner.unary(req, path, codec).await
        }
        /// Registers an exchange using RegisterExchangeRequest and returns a RegisterExchangeResponse.
        /// This method registers an exchange and start consuming if for message routing using AMQP
        /// Returns a RegisterExchangeResponse confirming the registration.
        pub async fn register_exchange(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterExchangeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterExchangeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/RegisterExchange",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "RegisterExchange"));
            self.inner.unary(req, path, codec).await
        }
        /// Sends a message to a queue using QueueMessageRequest and returns a QueueMessageResponse.
        /// This method sends a message to a registered queue for processing.
        /// Returns a QueueMessageResponse confirming the message transmission.
        pub async fn queue_message(
            &mut self,
            request: impl tonic::IntoRequest<super::QueueMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueueMessageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/QueueMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "QueueMessage"));
            self.inner.unary(req, path, codec).await
        }
        /// Unregisters a queue using UnRegisterQueueRequest and returns an UnRegisterQueueResponse.
        /// This method unregisters a previously registered queue or Exchange.
        /// Returns an UnRegisterQueueResponse confirming the unregistration.
        pub async fn un_register_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::UnRegisterQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnRegisterQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/UnRegisterQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "UnRegisterQueue"));
            self.inner.unary(req, path, codec).await
        }
        /// Watches for changes using WatchRequest and returns a WatchResponse.
        /// This method enables clients to watch for changes in a MongoDB collections, use paths (JSONQuerys) to limit what documents to wath.
        /// Returns a WatchResponse with relevant notifications.
        pub async fn watch(
            &mut self,
            request: impl tonic::IntoRequest<super::WatchRequest>,
        ) -> std::result::Result<tonic::Response<super::WatchResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/Watch",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("openiap.FlowService", "Watch"));
            self.inner.unary(req, path, codec).await
        }
        /// Stops watching for changes using UnWatchRequest and returns an UnWatchResponse.
        /// This method stops the client from watching for changes formerly registered using Watch
        /// Returns an UnWatchResponse confirming the cessation of watching.
        pub async fn un_watch(
            &mut self,
            request: impl tonic::IntoRequest<super::UnWatchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnWatchResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/UnWatch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "UnWatch"));
            self.inner.unary(req, path, codec).await
        }
        /// This method pushes (adds) a `Workitem` to a 'WorkItemQueue'
        /// Returns a PushWorkitemResponse confirming the operation.
        pub async fn push_workitem(
            &mut self,
            request: impl tonic::IntoRequest<super::PushWorkitemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PushWorkitemResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/PushWorkitem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "PushWorkitem"));
            self.inner.unary(req, path, codec).await
        }
        /// Pushes multiple `Workitem`s using PushWorkitemsRequest and returns a PushWorkitemsResponse.
        /// This method pushes multiple `Workitem`s to a 'WorkItemQueue'.
        /// Returns a PushWorkitemsResponse confirming the operation.
        pub async fn push_workitems(
            &mut self,
            request: impl tonic::IntoRequest<super::PushWorkitemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PushWorkitemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/PushWorkitems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "PushWorkitems"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a `Workitem` using UpdateWorkitemRequest and returns an UpdateWorkitemResponse.
        /// This method updates a `Workitem` in the 'WorkItemQueue'.
        /// Returns an UpdateWorkitemResponse confirming the update.
        pub async fn update_workitem(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateWorkitemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkitemResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/UpdateWorkitem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "UpdateWorkitem"));
            self.inner.unary(req, path, codec).await
        }
        /// Pops a `Workitem` using PopWorkitemRequest and returns a PopWorkitemResponse.
        /// This method pops a `Workitem` from the 'WorkItemQueue' for execution.
        /// Returns a PopWorkitemResponse with the popped `Workitem`.
        pub async fn pop_workitem(
            &mut self,
            request: impl tonic::IntoRequest<super::PopWorkitemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PopWorkitemResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/PopWorkitem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "PopWorkitem"));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `Workitem` using DeleteWorkitemRequest and returns a DeleteWorkitemResponse.
        /// This method deletes a `Workitem` from the 'WorkItemQueue'.
        /// Returns a DeleteWorkitemResponse confirming the deletion.
        pub async fn delete_workitem(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteWorkitemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteWorkitemResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/DeleteWorkitem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "DeleteWorkitem"));
            self.inner.unary(req, path, codec).await
        }
        /// This Created a new `WorkitemQueue'. These Queues can store `Workitem`s
        /// Returns an AddWorkItemQueueResponse confirming the addition.
        pub async fn add_work_item_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::AddWorkItemQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddWorkItemQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/AddWorkItemQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "AddWorkItemQueue"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing `WorkitemQueue'
        /// This method updates the configuration of a `WorkitemQueue'.
        /// Will also deleted all associated `Workitem`s if purge is enabled.
        /// Returns an UpdateWorkItemQueueResponse confirming the update.
        pub async fn update_work_item_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateWorkItemQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkItemQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/UpdateWorkItemQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "UpdateWorkItemQueue"));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `WorkitemQueue'
        /// This method deletes a `WorkitemQueue' queue. Will also deleted all associated `Workitem`s if purge is enabled.
        /// Returns a DeleteWorkItemQueueResponse confirming the deletion.
        pub async fn delete_work_item_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteWorkItemQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteWorkItemQueueResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/DeleteWorkItemQueue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "DeleteWorkItemQueue"));
            self.inner.unary(req, path, codec).await
        }
        /// Ensures the existence of a customer using EnsureCustomerRequest and returns an EnsureCustomerResponse.
        /// This method ensures that a customer exists in the system and performs necessary actions.
        /// Returns an EnsureCustomerResponse confirming the operation.
        pub async fn ensure_customer(
            &mut self,
            request: impl tonic::IntoRequest<super::EnsureCustomerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EnsureCustomerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/EnsureCustomer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "EnsureCustomer"));
            self.inner.unary(req, path, codec).await
        }
        /// Execute a workflow on a OpenRPA robot. If rpc is true, will wait for reply and return reply ( this can take a long time !)
        pub async fn invoke_open_rpa(
            &mut self,
            request: impl tonic::IntoRequest<super::InvokeOpenRpaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InvokeOpenRpaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/InvokeOpenRPA",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "InvokeOpenRPA"));
            self.inner.unary(req, path, codec).await
        }
        /// Start an agent inside Docker or Kubernetes
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        pub async fn start_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::StartAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartAgentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/StartAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "StartAgent"));
            self.inner.unary(req, path, codec).await
        }
        /// Stop an agent running inside Docker or Kubernetes
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        pub async fn stop_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::StopAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StopAgentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/StopAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "StopAgent"));
            self.inner.unary(req, path, codec).await
        }
        /// Return the console output of an running agent, can be in docker, kubernetes or running remote.
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        pub async fn get_agent_log(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAgentLogRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAgentLogResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/GetAgentLog",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "GetAgentLog"));
            self.inner.unary(req, path, codec).await
        }
        /// Return a list of pods for an running agent. Docker and Kubernetes only.
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        pub async fn get_agent_pods(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAgentPodsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAgentPodsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/GetAgentPods",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "GetAgentPods"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove an agent pod, found with GetAgentPods. Docker and Kubernetes only.
        /// On kubernetes this will restart it, on Docker this will kill it
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        pub async fn delete_agent_pod(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAgentPodRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteAgentPodResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/DeleteAgentPod",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "DeleteAgentPod"));
            self.inner.unary(req, path, codec).await
        }
        /// Remove an agent if running. Docker and Kubernetes only.
        /// Removes instance on docker, remove deployment, ingress and other resources on Kubernetes
        /// agentid is the _id of an agent from the agents collection
        /// Requires delete permission on agent
        pub async fn delete_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteAgentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/DeleteAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "DeleteAgent"));
            self.inner.unary(req, path, codec).await
        }
        /// Create an Index on a MongoDB Collection
        /// Will not fail if exists, but will fail if spec is different from existing.
        /// Require admins rights
        pub async fn create_index(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIndexRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateIndexResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/CreateIndex",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "CreateIndex"));
            self.inner.unary(req, path, codec).await
        }
        /// Create an Index on a MongoDB Collection
        /// Will not fail if exists, but will fail if spec is different from existing.
        /// Require admins rights
        pub async fn get_indexes(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIndexesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetIndexesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/GetIndexes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "GetIndexes"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete an Index from a MongoDB Collection
        /// Require admins rights
        pub async fn drop_index(
            &mut self,
            request: impl tonic::IntoRequest<super::DropIndexRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DropIndexResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/DropIndex",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "DropIndex"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete an agent Package.
        /// Removes the associated file and then delete te package from the agents collection.
        /// Requires delete permission on the Package
        pub async fn delete_package(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeletePackageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openiap.FlowService/DeletePackage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openiap.FlowService", "DeletePackage"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod flow_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with FlowServiceServer.
    #[async_trait]
    pub trait FlowService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the SetupStream method.
        type SetupStreamStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Envelope, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Establishes a bidirectional streaming connection for sending and receiving Envelopes.
        /// This method is used to set up a real-time data stream for communication.
        /// Returns a bidirectional stream of Envelopes.
        async fn setup_stream(
            &self,
            request: tonic::Request<tonic::Streaming<super::Envelope>>,
        ) -> std::result::Result<
            tonic::Response<Self::SetupStreamStream>,
            tonic::Status,
        >;
        /// Signs in a user with the provided SigninRequest and returns a SigninResponse.
        /// This method authenticates a user and provides access to the OpenFlow system.
        /// Returns a SigninResponse containing authentication details.
        async fn signin(
            &self,
            request: tonic::Request<super::SigninRequest>,
        ) -> std::result::Result<tonic::Response<super::SigninResponse>, tonic::Status>;
        /// Downloads a file from OpenFlow
        /// This method retrieves files from the OpenFlow system based on the specified criteria.
        /// This will initiaize a DownLoad stream, and once completed send send a DownloadResponse
        async fn download(
            &self,
            request: tonic::Request<super::DownloadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DownloadResponse>,
            tonic::Status,
        >;
        /// Uploads data based on the provided UploadRequest and returns an UploadResponse.
        /// This method allows users to upload data to the OpenFlow system.
        /// Returns an UploadResponse confirming the successful upload.
        async fn upload(
            &self,
            request: tonic::Request<super::UploadRequest>,
        ) -> std::result::Result<tonic::Response<super::UploadResponse>, tonic::Status>;
        /// Executes a custom command in OpenIAP Flow.
        /// This method enables the execution of custom commands within the OpenFlow system.
        /// Returns a CustomCommandResponse with the result of the command execution.
        async fn custom_command(
            &self,
            request: tonic::Request<super::CustomCommandRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomCommandResponse>,
            tonic::Status,
        >;
        /// Lists all MongoDB collections the user has access to.
        /// This method provides a list of collections that the user can interact with in the MongoDB database.
        /// Returns a ListCollectionsResponse containing collection names.
        async fn list_collections(
            &self,
            request: tonic::Request<super::ListCollectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCollectionsResponse>,
            tonic::Status,
        >;
        /// Drops a MongoDB Collection, requires user is a member of admins role.
        /// This method allows administrators to delete a MongoDB collection.
        /// Returns a DropCollectionResponse confirming the deletion.
        async fn drop_collection(
            &self,
            request: tonic::Request<super::DropCollectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DropCollectionResponse>,
            tonic::Status,
        >;
        /// Creates a new MongoDB collection, useful if you need to create with parameters like creating a TimeSeries Collection.
        /// This method creates a new MongoDB collection with optional parameters.
        /// Returns a CreateCollectionResponse indicating the success of collection creation.
        async fn create_collection(
            &self,
            request: tonic::Request<super::CreateCollectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateCollectionResponse>,
            tonic::Status,
        >;
        /// Performs a query using QueryRequest and returns a QueryResponse.
        /// This method executes a query operation in the MongoDB database.
        /// Returns a QueryResponse with query results.
        async fn query(
            &self,
            request: tonic::Request<super::QueryRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryResponse>, tonic::Status>;
        /// Retrieves a document's version using GetDocumentVersionRequest and returns a GetDocumentVersionResponse.
        /// This method retrieves a specific version of a document.
        /// Returns a GetDocumentVersionResponse with the requested document version.
        async fn get_document_version(
            &self,
            request: tonic::Request<super::GetDocumentVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDocumentVersionResponse>,
            tonic::Status,
        >;
        /// Aggregates data based on AggregateRequest and returns an AggregateResponse.
        /// This method performs data aggregation operations on the MongoDB database.
        /// Returns an AggregateResponse with the aggregated data.
        async fn aggregate(
            &self,
            request: tonic::Request<super::AggregateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AggregateResponse>,
            tonic::Status,
        >;
        /// Counts documents based on CountRequest and returns a CountResponse.
        /// This method counts documents in the MongoDB database based on specified criteria.
        /// Returns a CountResponse with the count result.
        async fn count(
            &self,
            request: tonic::Request<super::CountRequest>,
        ) -> std::result::Result<tonic::Response<super::CountResponse>, tonic::Status>;
        /// Inserts a single document using InsertOneRequest and returns an InsertOneResponse.
        /// This method inserts a single document into the MongoDB database.
        /// Returns an InsertOneResponse confirming the insertion.
        async fn insert_one(
            &self,
            request: tonic::Request<super::InsertOneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InsertOneResponse>,
            tonic::Status,
        >;
        /// Inserts multiple documents using InsertManyRequest and returns an InsertManyResponse.
        /// This method inserts multiple documents into the MongoDB database.
        /// Returns an InsertManyResponse confirming the insertions.
        async fn insert_many(
            &self,
            request: tonic::Request<super::InsertManyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InsertManyResponse>,
            tonic::Status,
        >;
        /// Updates a single document using UpdateOneRequest and returns an UpdateOneResponse.
        /// This method updates a single document in the MongoDB database.
        /// Returns an UpdateOneResponse confirming the update.
        async fn update_one(
            &self,
            request: tonic::Request<super::UpdateOneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateOneResponse>,
            tonic::Status,
        >;
        /// Updates documents using UpdateDocumentRequest and returns an UpdateDocumentResponse.
        /// This method updates multiple documents in the MongoDB database.
        /// Returns an UpdateDocumentResponse confirming the updates.
        async fn update_document(
            &self,
            request: tonic::Request<super::UpdateDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateDocumentResponse>,
            tonic::Status,
        >;
        /// Inserts or updates a single document using InsertOrUpdateOneRequest and returns an InsertOrUpdateOneResponse.
        /// This method either inserts or updates a single document in the MongoDB database.
        /// Returns an InsertOrUpdateOneResponse confirming the operation.
        async fn insert_or_update_one(
            &self,
            request: tonic::Request<super::InsertOrUpdateOneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InsertOrUpdateOneResponse>,
            tonic::Status,
        >;
        /// Inserts or updates multiple documents using InsertOrUpdateManyRequest and returns an InsertOrUpdateManyResponse.
        /// This method either inserts or updates multiple documents in the MongoDB database.
        /// Returns an InsertOrUpdateManyResponse confirming the operation.
        async fn insert_or_update_many(
            &self,
            request: tonic::Request<super::InsertOrUpdateManyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InsertOrUpdateManyResponse>,
            tonic::Status,
        >;
        /// Deletes a single document using DeleteOneRequest and returns a DeleteOneResponse.
        /// This method deletes a single document from the MongoDB database.
        /// Returns a DeleteOneResponse confirming the deletion.
        async fn delete_one(
            &self,
            request: tonic::Request<super::DeleteOneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteOneResponse>,
            tonic::Status,
        >;
        /// Deletes multiple documents using DeleteManyRequest and returns a DeleteManyResponse.
        /// This method deletes multiple documents from the MongoDB database.
        /// Returns a DeleteManyResponse confirming the deletions.
        async fn delete_many(
            &self,
            request: tonic::Request<super::DeleteManyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteManyResponse>,
            tonic::Status,
        >;
        /// Registers a queue using RegisterQueueRequest and returns a RegisterQueueResponse.
        /// This method registers and starts consuming a queue for message routing using AMQP
        /// Returns a RegisterQueueResponse confirming the registration.
        async fn register_queue(
            &self,
            request: tonic::Request<super::RegisterQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterQueueResponse>,
            tonic::Status,
        >;
        /// Registers an exchange using RegisterExchangeRequest and returns a RegisterExchangeResponse.
        /// This method registers an exchange and start consuming if for message routing using AMQP
        /// Returns a RegisterExchangeResponse confirming the registration.
        async fn register_exchange(
            &self,
            request: tonic::Request<super::RegisterExchangeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterExchangeResponse>,
            tonic::Status,
        >;
        /// Sends a message to a queue using QueueMessageRequest and returns a QueueMessageResponse.
        /// This method sends a message to a registered queue for processing.
        /// Returns a QueueMessageResponse confirming the message transmission.
        async fn queue_message(
            &self,
            request: tonic::Request<super::QueueMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueueMessageResponse>,
            tonic::Status,
        >;
        /// Unregisters a queue using UnRegisterQueueRequest and returns an UnRegisterQueueResponse.
        /// This method unregisters a previously registered queue or Exchange.
        /// Returns an UnRegisterQueueResponse confirming the unregistration.
        async fn un_register_queue(
            &self,
            request: tonic::Request<super::UnRegisterQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnRegisterQueueResponse>,
            tonic::Status,
        >;
        /// Watches for changes using WatchRequest and returns a WatchResponse.
        /// This method enables clients to watch for changes in a MongoDB collections, use paths (JSONQuerys) to limit what documents to wath.
        /// Returns a WatchResponse with relevant notifications.
        async fn watch(
            &self,
            request: tonic::Request<super::WatchRequest>,
        ) -> std::result::Result<tonic::Response<super::WatchResponse>, tonic::Status>;
        /// Stops watching for changes using UnWatchRequest and returns an UnWatchResponse.
        /// This method stops the client from watching for changes formerly registered using Watch
        /// Returns an UnWatchResponse confirming the cessation of watching.
        async fn un_watch(
            &self,
            request: tonic::Request<super::UnWatchRequest>,
        ) -> std::result::Result<tonic::Response<super::UnWatchResponse>, tonic::Status>;
        /// This method pushes (adds) a `Workitem` to a 'WorkItemQueue'
        /// Returns a PushWorkitemResponse confirming the operation.
        async fn push_workitem(
            &self,
            request: tonic::Request<super::PushWorkitemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PushWorkitemResponse>,
            tonic::Status,
        >;
        /// Pushes multiple `Workitem`s using PushWorkitemsRequest and returns a PushWorkitemsResponse.
        /// This method pushes multiple `Workitem`s to a 'WorkItemQueue'.
        /// Returns a PushWorkitemsResponse confirming the operation.
        async fn push_workitems(
            &self,
            request: tonic::Request<super::PushWorkitemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PushWorkitemsResponse>,
            tonic::Status,
        >;
        /// Updates a `Workitem` using UpdateWorkitemRequest and returns an UpdateWorkitemResponse.
        /// This method updates a `Workitem` in the 'WorkItemQueue'.
        /// Returns an UpdateWorkitemResponse confirming the update.
        async fn update_workitem(
            &self,
            request: tonic::Request<super::UpdateWorkitemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkitemResponse>,
            tonic::Status,
        >;
        /// Pops a `Workitem` using PopWorkitemRequest and returns a PopWorkitemResponse.
        /// This method pops a `Workitem` from the 'WorkItemQueue' for execution.
        /// Returns a PopWorkitemResponse with the popped `Workitem`.
        async fn pop_workitem(
            &self,
            request: tonic::Request<super::PopWorkitemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PopWorkitemResponse>,
            tonic::Status,
        >;
        /// Deletes a `Workitem` using DeleteWorkitemRequest and returns a DeleteWorkitemResponse.
        /// This method deletes a `Workitem` from the 'WorkItemQueue'.
        /// Returns a DeleteWorkitemResponse confirming the deletion.
        async fn delete_workitem(
            &self,
            request: tonic::Request<super::DeleteWorkitemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteWorkitemResponse>,
            tonic::Status,
        >;
        /// This Created a new `WorkitemQueue'. These Queues can store `Workitem`s
        /// Returns an AddWorkItemQueueResponse confirming the addition.
        async fn add_work_item_queue(
            &self,
            request: tonic::Request<super::AddWorkItemQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddWorkItemQueueResponse>,
            tonic::Status,
        >;
        /// Updates an existing `WorkitemQueue'
        /// This method updates the configuration of a `WorkitemQueue'.
        /// Will also deleted all associated `Workitem`s if purge is enabled.
        /// Returns an UpdateWorkItemQueueResponse confirming the update.
        async fn update_work_item_queue(
            &self,
            request: tonic::Request<super::UpdateWorkItemQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkItemQueueResponse>,
            tonic::Status,
        >;
        /// Deletes a `WorkitemQueue'
        /// This method deletes a `WorkitemQueue' queue. Will also deleted all associated `Workitem`s if purge is enabled.
        /// Returns a DeleteWorkItemQueueResponse confirming the deletion.
        async fn delete_work_item_queue(
            &self,
            request: tonic::Request<super::DeleteWorkItemQueueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteWorkItemQueueResponse>,
            tonic::Status,
        >;
        /// Ensures the existence of a customer using EnsureCustomerRequest and returns an EnsureCustomerResponse.
        /// This method ensures that a customer exists in the system and performs necessary actions.
        /// Returns an EnsureCustomerResponse confirming the operation.
        async fn ensure_customer(
            &self,
            request: tonic::Request<super::EnsureCustomerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EnsureCustomerResponse>,
            tonic::Status,
        >;
        /// Execute a workflow on a OpenRPA robot. If rpc is true, will wait for reply and return reply ( this can take a long time !)
        async fn invoke_open_rpa(
            &self,
            request: tonic::Request<super::InvokeOpenRpaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InvokeOpenRpaResponse>,
            tonic::Status,
        >;
        /// Start an agent inside Docker or Kubernetes
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        async fn start_agent(
            &self,
            request: tonic::Request<super::StartAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartAgentResponse>,
            tonic::Status,
        >;
        /// Stop an agent running inside Docker or Kubernetes
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        async fn stop_agent(
            &self,
            request: tonic::Request<super::StopAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StopAgentResponse>,
            tonic::Status,
        >;
        /// Return the console output of an running agent, can be in docker, kubernetes or running remote.
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        async fn get_agent_log(
            &self,
            request: tonic::Request<super::GetAgentLogRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAgentLogResponse>,
            tonic::Status,
        >;
        /// Return a list of pods for an running agent. Docker and Kubernetes only.
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        async fn get_agent_pods(
            &self,
            request: tonic::Request<super::GetAgentPodsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAgentPodsResponse>,
            tonic::Status,
        >;
        /// Remove an agent pod, found with GetAgentPods. Docker and Kubernetes only.
        /// On kubernetes this will restart it, on Docker this will kill it
        /// agentid is the _id of an agent from the agents collection
        /// Requires invoke permission on agent
        async fn delete_agent_pod(
            &self,
            request: tonic::Request<super::DeleteAgentPodRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteAgentPodResponse>,
            tonic::Status,
        >;
        /// Remove an agent if running. Docker and Kubernetes only.
        /// Removes instance on docker, remove deployment, ingress and other resources on Kubernetes
        /// agentid is the _id of an agent from the agents collection
        /// Requires delete permission on agent
        async fn delete_agent(
            &self,
            request: tonic::Request<super::DeleteAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteAgentResponse>,
            tonic::Status,
        >;
        /// Create an Index on a MongoDB Collection
        /// Will not fail if exists, but will fail if spec is different from existing.
        /// Require admins rights
        async fn create_index(
            &self,
            request: tonic::Request<super::CreateIndexRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateIndexResponse>,
            tonic::Status,
        >;
        /// Create an Index on a MongoDB Collection
        /// Will not fail if exists, but will fail if spec is different from existing.
        /// Require admins rights
        async fn get_indexes(
            &self,
            request: tonic::Request<super::GetIndexesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetIndexesResponse>,
            tonic::Status,
        >;
        /// Delete an Index from a MongoDB Collection
        /// Require admins rights
        async fn drop_index(
            &self,
            request: tonic::Request<super::DropIndexRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DropIndexResponse>,
            tonic::Status,
        >;
        /// Delete an agent Package.
        /// Removes the associated file and then delete te package from the agents collection.
        /// Requires delete permission on the Package
        async fn delete_package(
            &self,
            request: tonic::Request<super::DeletePackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeletePackageResponse>,
            tonic::Status,
        >;
    }
    /// Service for managing OpenIAP Flow (OpenFlow)
    #[derive(Debug)]
    pub struct FlowServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> FlowServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for FlowServiceServer<T>
    where
        T: FlowService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/openiap.FlowService/SetupStream" => {
                    #[allow(non_camel_case_types)]
                    struct SetupStreamSvc<T: FlowService>(pub Arc<T>);
                    impl<T: FlowService> tonic::server::StreamingService<super::Envelope>
                    for SetupStreamSvc<T> {
                        type Response = super::Envelope;
                        type ResponseStream = T::SetupStreamStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::Envelope>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::setup_stream(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetupStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/Signin" => {
                    #[allow(non_camel_case_types)]
                    struct SigninSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::SigninRequest>
                    for SigninSvc<T> {
                        type Response = super::SigninResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SigninRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::signin(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SigninSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/Download" => {
                    #[allow(non_camel_case_types)]
                    struct DownloadSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DownloadRequest>
                    for DownloadSvc<T> {
                        type Response = super::DownloadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DownloadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::download(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DownloadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/Upload" => {
                    #[allow(non_camel_case_types)]
                    struct UploadSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::UploadRequest>
                    for UploadSvc<T> {
                        type Response = super::UploadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UploadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::upload(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/CustomCommand" => {
                    #[allow(non_camel_case_types)]
                    struct CustomCommandSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::CustomCommandRequest>
                    for CustomCommandSvc<T> {
                        type Response = super::CustomCommandResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CustomCommandRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::custom_command(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CustomCommandSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/ListCollections" => {
                    #[allow(non_camel_case_types)]
                    struct ListCollectionsSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::ListCollectionsRequest>
                    for ListCollectionsSvc<T> {
                        type Response = super::ListCollectionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListCollectionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::list_collections(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListCollectionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/DropCollection" => {
                    #[allow(non_camel_case_types)]
                    struct DropCollectionSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DropCollectionRequest>
                    for DropCollectionSvc<T> {
                        type Response = super::DropCollectionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DropCollectionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::drop_collection(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DropCollectionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/CreateCollection" => {
                    #[allow(non_camel_case_types)]
                    struct CreateCollectionSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::CreateCollectionRequest>
                    for CreateCollectionSvc<T> {
                        type Response = super::CreateCollectionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateCollectionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::create_collection(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateCollectionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/Query" => {
                    #[allow(non_camel_case_types)]
                    struct QuerySvc<T: FlowService>(pub Arc<T>);
                    impl<T: FlowService> tonic::server::UnaryService<super::QueryRequest>
                    for QuerySvc<T> {
                        type Response = super::QueryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::query(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QuerySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/GetDocumentVersion" => {
                    #[allow(non_camel_case_types)]
                    struct GetDocumentVersionSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::GetDocumentVersionRequest>
                    for GetDocumentVersionSvc<T> {
                        type Response = super::GetDocumentVersionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetDocumentVersionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::get_document_version(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDocumentVersionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/Aggregate" => {
                    #[allow(non_camel_case_types)]
                    struct AggregateSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::AggregateRequest>
                    for AggregateSvc<T> {
                        type Response = super::AggregateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AggregateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::aggregate(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AggregateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/Count" => {
                    #[allow(non_camel_case_types)]
                    struct CountSvc<T: FlowService>(pub Arc<T>);
                    impl<T: FlowService> tonic::server::UnaryService<super::CountRequest>
                    for CountSvc<T> {
                        type Response = super::CountResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CountRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::count(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CountSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/InsertOne" => {
                    #[allow(non_camel_case_types)]
                    struct InsertOneSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::InsertOneRequest>
                    for InsertOneSvc<T> {
                        type Response = super::InsertOneResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InsertOneRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::insert_one(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InsertOneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/InsertMany" => {
                    #[allow(non_camel_case_types)]
                    struct InsertManySvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::InsertManyRequest>
                    for InsertManySvc<T> {
                        type Response = super::InsertManyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InsertManyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::insert_many(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InsertManySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/UpdateOne" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateOneSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::UpdateOneRequest>
                    for UpdateOneSvc<T> {
                        type Response = super::UpdateOneResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateOneRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::update_one(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateOneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/UpdateDocument" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateDocumentSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::UpdateDocumentRequest>
                    for UpdateDocumentSvc<T> {
                        type Response = super::UpdateDocumentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateDocumentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::update_document(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateDocumentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/InsertOrUpdateOne" => {
                    #[allow(non_camel_case_types)]
                    struct InsertOrUpdateOneSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::InsertOrUpdateOneRequest>
                    for InsertOrUpdateOneSvc<T> {
                        type Response = super::InsertOrUpdateOneResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InsertOrUpdateOneRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::insert_or_update_one(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InsertOrUpdateOneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/InsertOrUpdateMany" => {
                    #[allow(non_camel_case_types)]
                    struct InsertOrUpdateManySvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::InsertOrUpdateManyRequest>
                    for InsertOrUpdateManySvc<T> {
                        type Response = super::InsertOrUpdateManyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InsertOrUpdateManyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::insert_or_update_many(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InsertOrUpdateManySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/DeleteOne" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteOneSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DeleteOneRequest>
                    for DeleteOneSvc<T> {
                        type Response = super::DeleteOneResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteOneRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::delete_one(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteOneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/DeleteMany" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteManySvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DeleteManyRequest>
                    for DeleteManySvc<T> {
                        type Response = super::DeleteManyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteManyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::delete_many(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteManySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/RegisterQueue" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterQueueSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::RegisterQueueRequest>
                    for RegisterQueueSvc<T> {
                        type Response = super::RegisterQueueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterQueueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::register_queue(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterQueueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/RegisterExchange" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterExchangeSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::RegisterExchangeRequest>
                    for RegisterExchangeSvc<T> {
                        type Response = super::RegisterExchangeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterExchangeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::register_exchange(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterExchangeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/QueueMessage" => {
                    #[allow(non_camel_case_types)]
                    struct QueueMessageSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::QueueMessageRequest>
                    for QueueMessageSvc<T> {
                        type Response = super::QueueMessageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueueMessageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::queue_message(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueueMessageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/UnRegisterQueue" => {
                    #[allow(non_camel_case_types)]
                    struct UnRegisterQueueSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::UnRegisterQueueRequest>
                    for UnRegisterQueueSvc<T> {
                        type Response = super::UnRegisterQueueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnRegisterQueueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::un_register_queue(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnRegisterQueueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/Watch" => {
                    #[allow(non_camel_case_types)]
                    struct WatchSvc<T: FlowService>(pub Arc<T>);
                    impl<T: FlowService> tonic::server::UnaryService<super::WatchRequest>
                    for WatchSvc<T> {
                        type Response = super::WatchResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WatchRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::watch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WatchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/UnWatch" => {
                    #[allow(non_camel_case_types)]
                    struct UnWatchSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::UnWatchRequest>
                    for UnWatchSvc<T> {
                        type Response = super::UnWatchResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnWatchRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::un_watch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnWatchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/PushWorkitem" => {
                    #[allow(non_camel_case_types)]
                    struct PushWorkitemSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::PushWorkitemRequest>
                    for PushWorkitemSvc<T> {
                        type Response = super::PushWorkitemResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PushWorkitemRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::push_workitem(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PushWorkitemSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/PushWorkitems" => {
                    #[allow(non_camel_case_types)]
                    struct PushWorkitemsSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::PushWorkitemsRequest>
                    for PushWorkitemsSvc<T> {
                        type Response = super::PushWorkitemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PushWorkitemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::push_workitems(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PushWorkitemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/UpdateWorkitem" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateWorkitemSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::UpdateWorkitemRequest>
                    for UpdateWorkitemSvc<T> {
                        type Response = super::UpdateWorkitemResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateWorkitemRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::update_workitem(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateWorkitemSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/PopWorkitem" => {
                    #[allow(non_camel_case_types)]
                    struct PopWorkitemSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::PopWorkitemRequest>
                    for PopWorkitemSvc<T> {
                        type Response = super::PopWorkitemResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PopWorkitemRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::pop_workitem(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PopWorkitemSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/DeleteWorkitem" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteWorkitemSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DeleteWorkitemRequest>
                    for DeleteWorkitemSvc<T> {
                        type Response = super::DeleteWorkitemResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteWorkitemRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::delete_workitem(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteWorkitemSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/AddWorkItemQueue" => {
                    #[allow(non_camel_case_types)]
                    struct AddWorkItemQueueSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::AddWorkItemQueueRequest>
                    for AddWorkItemQueueSvc<T> {
                        type Response = super::AddWorkItemQueueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddWorkItemQueueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::add_work_item_queue(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddWorkItemQueueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/UpdateWorkItemQueue" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateWorkItemQueueSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::UpdateWorkItemQueueRequest>
                    for UpdateWorkItemQueueSvc<T> {
                        type Response = super::UpdateWorkItemQueueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateWorkItemQueueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::update_work_item_queue(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateWorkItemQueueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/DeleteWorkItemQueue" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteWorkItemQueueSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DeleteWorkItemQueueRequest>
                    for DeleteWorkItemQueueSvc<T> {
                        type Response = super::DeleteWorkItemQueueResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteWorkItemQueueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::delete_work_item_queue(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteWorkItemQueueSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/EnsureCustomer" => {
                    #[allow(non_camel_case_types)]
                    struct EnsureCustomerSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::EnsureCustomerRequest>
                    for EnsureCustomerSvc<T> {
                        type Response = super::EnsureCustomerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EnsureCustomerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::ensure_customer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EnsureCustomerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/InvokeOpenRPA" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeOpenRPASvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::InvokeOpenRpaRequest>
                    for InvokeOpenRPASvc<T> {
                        type Response = super::InvokeOpenRpaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InvokeOpenRpaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::invoke_open_rpa(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeOpenRPASvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/StartAgent" => {
                    #[allow(non_camel_case_types)]
                    struct StartAgentSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::StartAgentRequest>
                    for StartAgentSvc<T> {
                        type Response = super::StartAgentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartAgentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::start_agent(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartAgentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/StopAgent" => {
                    #[allow(non_camel_case_types)]
                    struct StopAgentSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::StopAgentRequest>
                    for StopAgentSvc<T> {
                        type Response = super::StopAgentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopAgentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::stop_agent(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopAgentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/GetAgentLog" => {
                    #[allow(non_camel_case_types)]
                    struct GetAgentLogSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::GetAgentLogRequest>
                    for GetAgentLogSvc<T> {
                        type Response = super::GetAgentLogResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAgentLogRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::get_agent_log(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAgentLogSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/GetAgentPods" => {
                    #[allow(non_camel_case_types)]
                    struct GetAgentPodsSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::GetAgentPodsRequest>
                    for GetAgentPodsSvc<T> {
                        type Response = super::GetAgentPodsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAgentPodsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::get_agent_pods(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAgentPodsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/DeleteAgentPod" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteAgentPodSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DeleteAgentPodRequest>
                    for DeleteAgentPodSvc<T> {
                        type Response = super::DeleteAgentPodResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteAgentPodRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::delete_agent_pod(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteAgentPodSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/DeleteAgent" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteAgentSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DeleteAgentRequest>
                    for DeleteAgentSvc<T> {
                        type Response = super::DeleteAgentResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteAgentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::delete_agent(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteAgentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/CreateIndex" => {
                    #[allow(non_camel_case_types)]
                    struct CreateIndexSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::CreateIndexRequest>
                    for CreateIndexSvc<T> {
                        type Response = super::CreateIndexResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateIndexRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::create_index(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateIndexSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/GetIndexes" => {
                    #[allow(non_camel_case_types)]
                    struct GetIndexesSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::GetIndexesRequest>
                    for GetIndexesSvc<T> {
                        type Response = super::GetIndexesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetIndexesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::get_indexes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetIndexesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/DropIndex" => {
                    #[allow(non_camel_case_types)]
                    struct DropIndexSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DropIndexRequest>
                    for DropIndexSvc<T> {
                        type Response = super::DropIndexResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DropIndexRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::drop_index(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DropIndexSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/openiap.FlowService/DeletePackage" => {
                    #[allow(non_camel_case_types)]
                    struct DeletePackageSvc<T: FlowService>(pub Arc<T>);
                    impl<
                        T: FlowService,
                    > tonic::server::UnaryService<super::DeletePackageRequest>
                    for DeletePackageSvc<T> {
                        type Response = super::DeletePackageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeletePackageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FlowService>::delete_package(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeletePackageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for FlowServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "openiap.FlowService";
    impl<T> tonic::server::NamedService for FlowServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
